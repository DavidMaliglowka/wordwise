{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup Project Repository and CI/CD",
        "description": "Bootstrap the React 18 + Vite + TypeScript repository, set up initial project structure, and configure GitHub Actions for CI/CD.",
        "details": "Initialize a new React project using Vite with TypeScript. Configure ESLint, Prettier. Set up a basic GitHub Actions workflow for linting, building, and potentially testing on push/PR.",
        "testStrategy": "Verify repository is created, dependencies are installed, and the initial CI workflow runs successfully on GitHub Actions.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Configure Firebase Project and Data Models",
        "description": "Set up the Firebase project, configure Authentication, Firestore database with necessary collections (User, BrandProfile, Document, Suggestion, MetricSnapshot), and Firebase Storage. Define initial security rules.",
        "details": "Create a new Firebase project. Enable Authentication (Email/Password, Google). Set up Firestore collections based on the provided data models. Configure Firebase Storage for brand sample uploads. Write basic Firestore and Storage security rules to restrict access based on user authentication (uid). Ensure HTTPS is enforced.",
        "testStrategy": "Verify Firebase project is created, services are enabled, collections/storage buckets exist, and basic security rules are applied and tested via Firebase emulator or console.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Set Up Firebase Project",
            "description": "Create a new project in the Firebase Console and configure the project settings via Firebase CLI as needed.",
            "dependencies": [],
            "details": "Establish the Firebase project environment, integrate project identification, and set up billing and linking configurations if necessary.",
            "status": "done"
          },
          {
            "id": 2,
            "title": "Enable Firebase Authentication",
            "description": "Activate and configure the Firebase Authentication service to manage user sign-in processes.",
            "dependencies": [
              1
            ],
            "details": "Select appropriate authentication providers, register sign-in methods, and test authentication flows.",
            "status": "done"
          },
          {
            "id": 3,
            "title": "Create Firestore Collections",
            "description": "Set up Firestore collections for Users, BrandProfile, Document, Suggestion, and MetricSnapshot.",
            "dependencies": [
              1,
              2
            ],
            "details": "Design the schema for each collection, define document structures, and use Firebase CLI or Console for collection creation.\n<info added on 2025-06-16T21:26:02.982Z>\nSuccessfully implemented Firestore collections and service layer. Comprehensive TypeScript interfaces have been defined for all models, including User, BrandProfile, Document, Suggestion, and MetricSnapshot. The Firestore service layer now supports full CRUD operations, secured by detailed security rules enforcing user-based data isolation. Additionally, the authentication system has been enhanced to auto-create user profiles, and a test component is in place to verify the correctness of all operations. All Firestore collections are fully prepared for the WordWise AI application.\n</info added on 2025-06-16T21:26:02.982Z>",
            "status": "done"
          },
          {
            "id": 4,
            "title": "Configure Firebase Storage",
            "description": "Set up Firebase Storage to manage file uploads and ensure integration with the Firebase project.",
            "dependencies": [
              1,
              2
            ],
            "details": "Configure storage buckets, integrate file upload/download functionalities, and manage storage regions and rules.\n<info added on 2025-06-16T21:58:53.078Z>\nFirebase Storage has been fully configured and deployed. Firebase Console now shows Storage enabled with up-to-date security rules applied. All services are ready for testing, including file operations such as upload, download, delete, and metadata management. A StorageTest component is available at localhost:5173 for live verification, with tests covering profile images (5MB limit), brand assets (25MB limit), and documents (50MB limit). Additional features include file listing, download URL generation, progress tracking, and enforced security measures like user isolation, file type checks, and size restrictions.\n</info added on 2025-06-16T21:58:53.078Z>",
            "status": "done"
          },
          {
            "id": 5,
            "title": "Implement Basic Security Rules",
            "description": "Write security rules to enforce HTTPS and restrict access to authenticated users for both Firestore and Storage.",
            "dependencies": [
              3,
              4
            ],
            "details": "Develop rules that enforce HTTPS access, restrict unauthenticated access, and test the rules using Firebase emulators or simulators.",
            "status": "done"
          }
        ]
      },
      {
        "id": 3,
        "title": "Implement User Authentication",
        "description": "Implement user authentication flows: sign-up, sign-in, and sign-out using Firebase Authentication in the React frontend.",
        "details": "Use Firebase Auth SDK in the React application. Create UI components for sign-up and sign-in forms. Implement logic to call Firebase Auth methods. Manage user session state using Zustand or React Context. Ensure secure session management practices are followed.",
        "testStrategy": "Test user registration, login with valid/invalid credentials, and logout. Verify user state is correctly managed across sessions.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Develop Authentication UI Components",
            "description": "Design and implement the UI components for user sign-up, sign-in, and sign-out flows in the React application.",
            "dependencies": [],
            "details": "Create forms for sign-up and sign-in, design feedback/error messages, and implement a sign-out button. Ensure the UI is user-friendly and consistent with the overall app design.",
            "status": "done"
          },
          {
            "id": 2,
            "title": "Integrate Firebase Auth Methods",
            "description": "Connect the UI components with Firebase Auth services for handling user registration, login, and logout functionalities.",
            "dependencies": [
              1
            ],
            "details": "Implement Firebase functions such as createUserWithEmailAndPassword, signInWithEmailAndPassword, and signOut. Ensure proper error handling and response management for each operation.",
            "status": "done"
          },
          {
            "id": 3,
            "title": "Set Up State Management",
            "description": "Implement state management using either Zustand or React Context to manage the authentication state across the application.",
            "dependencies": [
              2
            ],
            "details": "Configure a global state store to track user authentication status and related data. Ensure the state updates in response to Firebase Auth events.",
            "status": "done"
          },
          {
            "id": 4,
            "title": "Integrate and Test Complete Authentication Flow",
            "description": "Integrate the UI, Firebase Auth methods, and state management to complete the authentication flows, followed by thorough testing.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Ensure that sign-up, sign-in, and sign-out actions correctly update the UI and global state. Test for edge cases and error scenarios to validate the complete user authentication flow.",
            "status": "done"
          }
        ]
      },
      {
        "id": 4,
        "title": "Develop Document CRUD Backend Functions",
        "description": "Develop Cloud Functions (Node 20) for Document CRUD operations (create, read, update, delete) interacting with Firestore.",
        "details": "Create Firebase Cloud Functions using Node.js (v20). Implement endpoints/functions for creating new documents (associating with user uid), fetching documents (list for a user, single by ID), updating document content, and deleting documents. Ensure functions enforce security rules based on the authenticated user's uid. Use Firebase Admin SDK.",
        "testStrategy": "Write unit tests for Cloud Functions. Manually test CRUD operations via Firebase emulator or deployed functions using authenticated requests.",
        "priority": "medium",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Develop Create Document Cloud Function",
            "description": "Implement a Cloud Function to create new documents in Firestore, integrating Firebase Admin SDK and enforcing user authentication.",
            "dependencies": [],
            "details": "Set up a Cloud Function endpoint to handle POST requests. Validate incoming data, enforce user authentication, and use the Firebase Admin SDK to write new documents to Firestore. Include comprehensive error handling and proper response management.\n<info added on 2025-06-16T23:32:51.459Z>\nImplemented a full suite of document CRUD Cloud Functions in functions/src/index.ts. This includes the createDocument POST endpoint with full data validation via Zod, JWT-based user authentication using the Firebase Admin SDK, and structured error handling with detailed logging. Additional endpoints—getDocuments, updateDocument, deleteDocument (with related data cascade deletion), and a health check—were developed to support complete document management. Frontend integration was updated with a new DocumentService class, revised TypeScript interfaces, and a DocumentTest component for complete CRUD operation testing. All functions have been compiled, tested, and are ready for deployment.\n</info added on 2025-06-16T23:32:51.459Z>",
            "status": "done"
          },
          {
            "id": 2,
            "title": "Develop Read Document Cloud Function",
            "description": "Implement a Cloud Function to retrieve documents from Firestore with secure access.",
            "dependencies": [
              1
            ],
            "details": "Set up a Cloud Function endpoint to handle GET requests. Use the Firebase Admin SDK to query and retrieve documents from Firestore. Validate user identity and permissions before allowing access, and ensure proper error handling and response formatting.",
            "status": "done"
          },
          {
            "id": 3,
            "title": "Develop Update Document Cloud Function",
            "description": "Implement a Cloud Function to update existing Firestore documents securely.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create a Cloud Function endpoint for handling PUT requests. Validate input data and user permissions, then use the Firebase Admin SDK to update the specified document in Firestore. Include robust error handling, input validation, and security checks to ensure data integrity.",
            "status": "done"
          },
          {
            "id": 4,
            "title": "Develop Delete Document Cloud Function",
            "description": "Implement a Cloud Function to delete documents from Firestore while enforcing user authentication.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Set up a Cloud Function endpoint for DELETE requests. Leverage the Firebase Admin SDK to remove documents from Firestore, and incorporate strict user authentication and authorization checks. Ensure appropriate error handling and security logging to track deletion events.",
            "status": "done"
          }
        ]
      },
      {
        "id": 5,
        "title": "Build Documents Dashboard UI",
        "description": "Build the Documents Dashboard UI including the global sidebar, content header (New document, Upload, Search), and the document grid gallery.",
        "details": "Implement the layout using React and Tailwind CSS, adhering to the specified structure (fixed sidebar, sticky header, grid). Use React-Query to fetch the list of documents for the logged-in user from the backend functions (Task 4). Implement infinite scroll/pagination (lazy-load 20 cards). Design document cards with metadata and quick actions. Implement empty state UI. Ensure responsiveness (sidebar collapse ≤ 1024 px).",
        "testStrategy": "Verify layout responsiveness. Test fetching and displaying documents. Test pagination/infinite scroll. Verify 'New document' button triggers document creation flow. Test empty state display.",
        "priority": "medium",
        "dependencies": [
          3,
          4
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Setup Global Sidebar and Layout Structure",
            "description": "Create the base structure of the dashboard including a global sidebar for navigation. Establish overall layout and routing scaffolding.",
            "dependencies": [],
            "details": "Develop a responsive sidebar with navigation links, ensuring proper hierarchy and styling. Establish foundational styles and basic component structure.\n<info added on 2025-06-17T03:04:10.457Z>\nCOMPLETED: Global Sidebar and Layout Structure Setup. The DashboardLayout.tsx component was implemented with a responsive sidebar that adapts between mobile and desktop views. It includes the WordWise “W” branding, navigation links for Documents, Version History, Trash, and Account, as well as a Get Pro CTA. A user profile section with sign-out functionality is available in the sidebar footer. Additional details include the mobile hamburger menu with a smooth sliding overlay, proper focus management and accessibility considerations, and a fixed sidebar width of 72px (288px) per PRD requirements. Tailwind CSS was used for styling, ensuring consistent z-index layering, smooth transitions, and a sticky header behavior on mobile.\n</info added on 2025-06-17T03:04:10.457Z>",
            "status": "done"
          },
          {
            "id": 2,
            "title": "Implement Content Header with Action Buttons",
            "description": "Design and implement the content header area that includes page title and primary action buttons for document operations.",
            "dependencies": [
              1
            ],
            "details": "Create the content header UI component with buttons for adding or filtering documents. Ensure proper placement relative to the global sidebar and consistency with design guidelines.\n<info added on 2025-06-17T03:05:34.027Z>\nImplemented the content header component within DocumentsDashboard.tsx. The header now features a sticky top positioning with proper z-index layering to remain visible during scrolling, a page title \"Documents\" styled with text-2xl bold typography, and three action buttons: a full-featured Search Field with a 320px width and magnifying glass icon that filters documents in real-time, a Secondary Upload File button with an upload icon, and a Primary New Document button with an indigo style and plus icon. The component includes responsive spacing, proper button grouping, clean visual hierarchy, live search functionality, and enhanced accessibility through focus management and outline/ring styles.\n</info added on 2025-06-17T03:05:34.027Z>",
            "status": "done"
          },
          {
            "id": 3,
            "title": "Develop Document Grid Gallery UI",
            "description": "Build the document gallery grid layout which displays document thumbnails or list items in a clean, organized manner.",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement a grid layout component to dynamically render document cards. Focus on modular design, card interactions, and styling for visual clarity.\n<info added on 2025-06-17T03:30:13.463Z>\nThe Document Grid Gallery UI has been completed. The DocumentCard component was developed to match exact PRD specifications, featuring fixed card dimensions (152px × 208px), document icon, title, content snippet, metadata display, a score badge placeholder, date stamp, and real-time reading time calculation at 200 WPM. Quick actions on hover include download and delete, with delete triggering an actual Firestore deletion and confirmation dialog. The grid layout employs a fully responsive CSS Grid system that scales from 2 to 8 columns based on screen size, with proper gap spacing and a masonry effect using “gap-4”. Additional interactive enhancements include hover states with shadow elevation, smooth transitions, animations, and event handling to avoid unwanted propagation. An empty state was also implemented with an illustrative DocumentTextIcon, contextual messaging for both no documents and no search results, and a call-to-action button for creating the first document.\n</info added on 2025-06-17T03:30:13.463Z>",
            "status": "done"
          },
          {
            "id": 4,
            "title": "Integrate Infinite Scroll/Pagination",
            "description": "Implement infinite scrolling or pagination for the document grid to efficiently load documents as users scroll.",
            "dependencies": [
              3
            ],
            "details": "Develop logic for fetching additional data when the user reaches a scroll threshold. Optimize performance and include loading states. Test for both infinite scroll and pagination behavior.\n<info added on 2025-06-17T03:30:52.148Z>\nAppend logic for infinite scroll/pagination integration. Implement a custom useInfiniteScroll hook using the Intersection Observer API to detect when the document grid is near the bottom. Update pagination state to manage the cursor (i.e., the last document snapshot) and modify DocumentService to support cursor-based pagination using Firestore’s startAfter method. Add logic to fetch and append the next batch of documents when scrolling reaches the threshold, including appropriate “loading more” state indicators and a fallback “Load More” button. Ensure the existing dynamic document array handling and error framework are extended to accommodate these enhancements.\n</info added on 2025-06-17T03:30:52.148Z>",
            "status": "done"
          },
          {
            "id": 5,
            "title": "Backend Data Integration and Responsive Design",
            "description": "Connect UI components to backend data fetching and ensure that the dashboard is fully responsive across devices.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Implement API integration for all document-related data and handle error states. Refine UI components to adjust for various screen sizes and test responsiveness thoroughly.\n<info added on 2025-06-17T03:55:55.230Z>\n✅ COMPLETED: Backend Data Integration and Responsive Design\n\nFinal Implementation Summary:\n• Connected the documents dashboard to Firestore with real-time updates and comprehensive error handling.\n• Fully resolved mobile layout issues through responsive grid adjustments, stacking header layout, and enhanced touch targets.\n• Updated card design per specifications: date repositioned at the top (format \"5 Jun\"), permanent download/trash icons, red circular badge for randomized edit counts, full-width cards with a fixed 240px height, and refined content spacing.\n• Optimized overall layout by replacing fixed height (h-screen) with min-h-screen for natural content growth, improved grid column utilization, and eliminated scroll issues caused by height constraints.\n</info added on 2025-06-17T03:55:55.230Z>",
            "status": "done"
          },
          {
            "id": 6,
            "title": "Implement Real Edit Count Logic",
            "description": "Replace the mock randomized edit count with actual edit tracking logic that reflects real document edit history.",
            "details": "Currently using Math.random() for edit counts. Need to implement proper edit tracking that stores and displays the actual number of edits/revisions remaining or completed for each document. This should integrate with the document data model and update in real-time as users make changes.\n<info added on 2025-06-17T04:33:39.008Z>\nInitial Analysis & Implementation Plan:\n\nCurrent state assessment shows that edit counts are currently generated using a random function and integrated into the document card display, while the Document interface lacks any dedicated edit tracking fields. The plan is to introduce an editCount field and optionally an editHistory array to the Document type to accurately track revisions.\n\nThe following steps will be taken:\n1. Update the Document type in src/types/firestore.ts by adding an optional editCount field and an optional editHistory array with an associated EditEntry interface (containing timestamp and type information).\n2. Modify Firestore rules (in firestore.rules) to permit updates including the editCount field.\n3. Adjust the DocumentCard component in src/pages/DocumentsDashboard.tsx to replace the random edit count logic with a reference to document.editCount (defaulting to 0 when undefined).\n4. Revise document update logic in both src/services/firestore.ts (DocumentService.updateDocument) and functions/src/index.ts to increment the editCount on each document update, ideally using Firestore’s atomic increment operation.\n5. Implement a migration strategy that initializes editCount to 0 for documents currently lacking this field while safely handling undefined values.\n\nThese modifications ensure backward compatibility, real-time accurate display and update of edit counts, and a more robust edit tracking system for each document.\n</info added on 2025-06-17T04:33:39.008Z>\n<info added on 2025-06-17T04:36:11.449Z>\nImplementation Complete - Phase 1\n\nChanges have been made across multiple areas:\n\n• Document Types (src/types/firestore.ts):\n  - Introduced an EditEntry interface to track edit details.\n  - Extended the Document interface with optional editCount and editHistory fields.\n  - Added an editCount field to the UpdateDocumentData interface.\n\n• Frontend Service (src/services/firestore.ts):\n  - Imported Firestore's increment functionality.\n  - Modified createDocument to initialize new documents with editCount set to 0.\n  - Updated updateDocument to atomically increment the editCount when substantive changes occur.\n\n• DocumentCard Component (src/pages/DocumentsDashboard.tsx):\n  - Replaced the temporary random edit count with a reference to document.editCount, defaulting to 0 if undefined.\n\n• Cloud Functions (functions/src/index.ts):\n  - Updated the updateDocument schema by including the editCount field.\n  - Modified createDocument to initialize editCount at 0.\n  - Enhanced updateDocument to perform an atomic increment of the editCount using admin.firestore.FieldValue.increment(1).\n\nAll updates have been implemented with a focus on ensuring backward compatibility. Existing documents will display 0 edits by default, while new documents and subsequent updates will correctly reflect real-time atomic updates to the edit count.\n\nNext steps include testing in the development environment to verify that edit counts increment properly on document updates and that no regressions occur with existing documents.\n</info added on 2025-06-17T04:36:11.449Z>\n<info added on 2025-06-17T04:37:00.206Z>\nTesting & Verification Plan:\n• Check Current Documents: Verify that all existing documents now show “0” in the red edit count badge, confirming that the fallback using document.editCount ?? 0 is functioning correctly.\n• Test New Document Creation: Create a new document (via helper functions or implemented UI) and confirm that it initializes with an editCount of 0.\n• Test Edit Count Increments: Update document content, title, or status to ensure that each substantive change increments the editCount by 1, and that multiple rapid updates are handled correctly through atomic operations.\n• Verify Console/Network Activity: Check the browser console and network tab to ensure there are no TypeScript errors related to the editCount field and no trace of random number generation in the DocumentCard.\nObservations to Confirm:\n– Document cards display “0” in the red badge as expected.\n– Frontend HMR updates the DocumentsDashboard component correctly.\n– Cloud Functions properly support and process editCount increments.\nThis plan validates the implementation for accurate, real-time edit tracking as document editing features are further developed.\n</info added on 2025-06-17T04:37:00.206Z>",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 5
          }
        ]
      },
      {
        "id": 6,
        "title": "Integrate Rich-Text Editor Component",
        "description": "Integrate a rich-text editor component (Lexical or Tiptap) into the application, setting up basic content editing capabilities and a placeholder.",
        "details": "Choose either Lexical or Tiptap. Integrate the editor into a React component. Configure it for basic text input, semantic elements, and a placeholder ('Type or paste (⌘+V)…'). Set up state management for the editor content. Implement the bottom-left toolbar with basic formatting (B, I, U, H1/H2, lists, link, strikethrough). Ensure standard hotkeys are supported.",
        "testStrategy": "Verify text input, formatting, and hotkeys work correctly. Ensure placeholder is displayed when empty. Test content persistence within the component.",
        "priority": "high",
        "dependencies": [
          5
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Evaluate and Select Rich-Text Editor Library",
            "description": "Research and compare Lexical and Tiptap for integration with React, considering factors like community support, compatibility, and ease of use.",
            "dependencies": [],
            "details": "Review documentation, experiment with demos, and decide which editor best fits the requirements of the application.\n<info added on 2025-06-17T04:44:02.298Z>\nDecision: Lexical Selected as Rich-Text Editor\n\nAfter evaluating Lexical against Tiptap, Lexical was selected for its lightweight, modular architecture, native TypeScript support, seamless React integration, and modern design. This decision aligns with WordWise’s needs for basic formatting—B, I, U, H1/H2, lists, links, and strikethrough—while supporting future enhancements like AI suggestions and real-time editing metrics.\n\nNext Steps:\n• Install the @lexical/react and core packages.\n• Configure LexicalComposer with basic setup.\n• Implement ContentEditable with a placeholder.\n• Integrate basic formatting plugins.\n</info added on 2025-06-17T04:44:02.298Z>",
            "status": "done"
          },
          {
            "id": 2,
            "title": "Set Up Basic Content Editing Capabilities",
            "description": "Integrate the selected rich-text editor into the React application and configure the basic content editing features.",
            "dependencies": [
              1
            ],
            "details": "Install necessary packages, add editor component to the UI, and ensure that basic text entry and editing work correctly.\n<info added on 2025-06-17T04:47:41.297Z>\nImplemented Lexical Editor by installing necessary Lexical packages (core, React integration, and additional nodes/utilities for rich-text, lists, links, etc.). Developed the LexicalEditor component (src/components/editor/LexicalEditor.tsx) which sets up LexicalComposer with proper configuration, integrates RichTextPlugin with ContentEditable (including a \"Type or paste (⌘+V)…\" placeholder), and adds HistoryPlugin for undo/redo functionality, Tailwind CSS-based theme configuration, support for headings, lists, links, quotes, and an error boundary. Created a test page (src/pages/EditorTest.tsx) to verify editor functionality with debug output for content changes. Temporarily modified App.tsx to load the test page and resolved import issues with Lexical HTML utilities. Basic text input, editing, undo/redo functionality, and rich-text node support are confirmed working, setting the stage for the next subtask on configuring the toolbar with formatting options.\n</info added on 2025-06-17T04:47:41.297Z>",
            "status": "done"
          },
          {
            "id": 3,
            "title": "Configure Toolbar with Formatting Options",
            "description": "Develop and integrate a toolbar for the rich-text editor that provides formatting options such as bold, italic, underline, and others.",
            "dependencies": [
              2
            ],
            "details": "Customize the toolbar to handle common formatting actions, ensuring a user-friendly interface and responsive design.\n<info added on 2025-06-17T04:55:41.414Z>\nToolbar Implementation Complete. The EditorToolbar now includes all required formatting tools: text formatting (Bold with Ctrl+B, Italic with Ctrl+I, Underline with Ctrl+U, and Strikethrough with click-to-toggle), list formatting (unordered and ordered lists), and link insertion with a URL prompt. Real-time state tracking highlights active buttons, and keyboard shortcuts are fully supported. The toolbar is styled with Tailwind CSS for a clean UI, features visual separators for clear grouping, and is positioned at the editor's bottom. Integration with LexicalEditor ensures automatic inclusion, real-time content updates via the OnChangePlugin, and robust error handling. This implementation meets design requirements and is ready for the next task on Editor state management.\n</info added on 2025-06-17T04:55:41.414Z>",
            "status": "done"
          },
          {
            "id": 4,
            "title": "Implement and Manage Editor State",
            "description": "Establish proper state management for the rich-text editor to handle content changes, undo/redo actions, and persistence.",
            "dependencies": [
              3
            ],
            "details": "Set up React state or use external libraries (e.g., Redux) to manage editor state, ensuring consistency and scalability.\n<info added on 2025-06-17T05:05:13.625Z>\nState Management Implementation Complete. The editor now features a robust state interface (EditorStateData) that tracks both text and HTML content, enabling real-time word and character counts along with empty state detection for parent components. Initial content management is handled via the InitialContentPlugin, ensuring a clean load of empty or pre-populated states with ref-based tracking to avoid unnecessary updates. An AutoSavePlugin has been integrated with a default 2000ms configurable delay, debouncing to minimize redundant API calls and managing timeouts through proper cleanup. Enhanced change tracking provides a comprehensive onChange callback that preserves HTML formatting and calculates metrics in real-time using performance-optimized hooks. Added keyboard shortcuts support includes manual saving (Ctrl/Cmd+S), standard formatting commands (Ctrl+B, I, U), as well as undo/redo (Ctrl+Z, Ctrl+Y) with cross-platform compatibility. A read-only mode is implemented with visual styling adjustments and disabled toolbar functionality for non-editable scenarios, complemented by advanced configuration options for customization such as auto-save delay and placeholder text. The technical implementation leverages React hooks, Lexical’s plugin architecture, and TypeScript interfaces to ensure a scalable, optimized, and production-ready state management system.\n</info added on 2025-06-17T05:05:13.625Z>",
            "status": "done"
          }
        ]
      },
      {
        "id": 7,
        "title": "Develop Grammar/Spell Check AI Endpoint",
        "description": "Create a Cloud Function endpoint that accepts text input and returns grammar and spelling suggestions using the OpenAI GPT-4o proof-reading model.",
        "details": "Create a Firebase Cloud Function. Use the OpenAI Node SDK to call the GPT-4o model with a prompt engineered for grammar and spelling correction. The function should accept text and return a structured list of suggestions (range, type, original, proposed, explanation). Implement edge caching keyed by text hash + feature to reduce latency and cost. Handle streaming responses from OpenAI.",
        "testStrategy": "Write unit tests for the function logic. Test the endpoint with various text inputs (correct, incorrect grammar/spelling) and verify the structure and content of the suggestions returned. Measure latency.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Environment Setup and Architecture Design",
            "description": "Set up the Cloud Function environment and design the overall architecture for integrating the GPT-4o model.",
            "dependencies": [],
            "details": "Define cloud resource configurations, outline the data flow, and create architecture diagrams to ensure all components, including AI integration and caching, are accounted for.\n<info added on 2025-06-17T04:51:04.305Z>\nArchitecture Design Complete\n\nBased on research and current codebase analysis, the design for the Grammar/Spell Check AI endpoint includes the following components:\n\nArchitecture Overview:\n• Cloud Function: Firebase HTTP function integrating the OpenAI GPT-4o API.\n• Runtime: Node.js 22, configured in functions/package.json.\n• Authentication: Firebase Auth token verification following current patterns.\n• Caching: Text hash-based caching with node-cache to maintain warm instances.\n• Response: Structured JSON containing grammar and spelling suggestions.\n\nTechnical Stack:\n• OpenAI SDK: Latest Node.js SDK for GPT-4o API calls.\n• Streaming: Real-time streaming responses.\n• Validation: Zod schema validation as used in existing functions.\n• Error Handling: Comprehensive try-catch blocks with structured error responses.\n• CORS: Implementation aligned with current frontend integration patterns.\n\nData Flow:\n1. Frontend sends request to Cloud Function with Firebase Auth token.\n2. Function validates token and input text.\n3. A text hash is generated to lookup cached results.\n4. Return cached result if found.\n5. If not cached, invoke the OpenAI GPT-4o API.\n6. Process the streaming response into structured suggestions.\n7. Cache the new result and return to the frontend.\n\nResponse Structure Example:\nStructure is defined by:\ninterface GrammarSuggestion {\n  range: { start: number; end: number };\n  type: 'grammar' | 'spelling';\n  original: string;\n  proposed: string;\n  explanation: string;\n  confidence: number;\n}\n\nSecurity Considerations:\n• Firebase Auth token verification.\n• Thorough input validation and sanitization.\n• Rate limiting strategies.\n• Secure handling of API keys via Firebase configuration.\n\nReady to proceed with the implementation.\n</info added on 2025-06-17T04:51:04.305Z>",
            "status": "done"
          },
          {
            "id": 2,
            "title": "Integrate OpenAI GPT-4o API",
            "description": "Develop and test the integration with the GPT-4o API, ensuring proper authentication and network configuration.",
            "dependencies": [
              1
            ],
            "details": "Implement the API call logic, handle authentication tokens, and verify connectivity with the OpenAI endpoint.\n<info added on 2025-06-17T04:55:49.690Z>\nOpenAI Integration Implementation Complete\n\nThe API call logic now features a fully implemented OpenAI GPT-4o API integration with comprehensive capabilities, including:\n\n• A dedicated OpenAI Utility Module that manages a singleton client instance with proper initialization and Firebase-based API key authentication.\n• Dynamic prompt engineering for both system and user contexts, with robust JSON response parsing and validation.\n• Full error handling covering all OpenAI error codes and graceful fallbacks.\n• Streaming API support enabling real-time responses.\n• Configurable options for grammar, spelling, style checks; structured JSON output; confidence scoring on a 0-1 scale; precise character positioning for text highlights; and rate-limit awareness.\n• Comprehensive logging for enhanced debugging and monitoring, ensuring complete end-to-end security and reliability.\n\nNext steps involve installing dependencies, configuring the OpenAI API key via Firebase, and integrating this functionality within the Cloud Function endpoint.\n</info added on 2025-06-17T04:55:49.690Z>",
            "status": "done"
          },
          {
            "id": 3,
            "title": "Prompt Engineering and Streaming Response Handling",
            "description": "Design and implement the prompt for grammar and spell checking along with handling the streaming responses from GPT-4o.",
            "dependencies": [
              2
            ],
            "details": "Develop effective prompts, set up event handlers for streaming data, and manage data flow to process partial responses.\n<info added on 2025-06-17T04:58:43.477Z>\nPrompt Engineering and Cloud Function Endpoint Complete! Successfully implemented a comprehensive grammar and spell check Cloud Function endpoint with advanced features:\n\nCore Implementation:\n- REST endpoint (POST /checkGrammar) with full validation.\n- Firebase token verification for authentication.\n- Input validation using a Zod schema with a 10k character limit.\n- Text hash-based caching integration for cache-hit optimization.\n\nPrompt Engineering Highlights:\n- Configurable dynamic system prompts for grammar, spelling, and style.\n- Enforced structured JSON response format from GPT-4o.\n- Confidence scoring on a 0–1 scale for suggestion reliability.\n- Accurate character range detection for editor integration.\n\nStreaming Response Support:\n- Server-Sent Events (SSE) for real-time streaming.\n- Live chunk processing to send responses to the frontend.\n- Graceful fallback to non-streaming mode for compatibility.\n- Appropriate stream headers for handling real-time data.\n\nPerformance & Reliability:\n- Integrated edge caching to reduce API calls and latency.\n- Comprehensive error handling with proper HTTP response codes.\n- Rate limit awareness to handle OpenAI restrictions gracefully.\n- Detailed logging for performance and usage metrics.\n\nResponse Structure used:\n{\n  success: true,\n  data: {\n    suggestions: [...],\n    processedText: string,\n    cached: boolean,\n    processingTimeMs: number\n  }\n}\n\nEndpoint is now ready for testing and seamless frontend integration in both streaming and non-streaming modes.\n</info added on 2025-06-17T04:58:43.477Z>",
            "status": "done"
          },
          {
            "id": 4,
            "title": "Edge Caching Implementation Based on Text Hash",
            "description": "Implement a caching mechanism based on a text hash to enhance performance and reduce latency for repeated requests.",
            "dependencies": [
              2
            ],
            "details": "Design a strategy to generate unique hashes from texts, manage cache storage and invalidation policies, and integrate caching with Cloud Functions.\n<info added on 2025-06-17T04:59:22.078Z>\nEdge Caching Implementation Details:\nThe caching system is now fully implemented and integrated within the checkGrammar endpoint. Unique cache keys are generated using a SHA-256 hash of normalized text combined with analysis options, ensuring collision resistance and distinct keys even with varied parameters. In-memory caching via NodeCache is configured with a default 1-hour TTL and automatic cleanup of expired entries. Complete performance monitoring has been added with detailed hit/miss statistics and cache key counts, and responses now include cache headers for frontend awareness. These enhancements significantly improve performance by reducing duplicate Calls to OpenAI and optimizing processing times.\n</info added on 2025-06-17T04:59:22.078Z>",
            "status": "done"
          },
          {
            "id": 5,
            "title": "Error Handling, Logging, and Performance Optimization",
            "description": "Incorporate robust error handling, logging mechanisms, and conduct performance testing to ensure reliability and efficiency.",
            "dependencies": [
              3,
              4
            ],
            "details": "Implement exception handling for API and caching errors, set up logging for debugging and monitoring, and perform load testing under various latency scenarios.\n<info added on 2025-06-17T05:03:10.437Z>\nImplemented comprehensive error handling, logging, and performance optimization. The update includes multi-level error handling that covers function, OpenAI API, and system-level errors with appropriate HTTP status responses (400, 401, 429, 500), detailed OpenAI error mapping, graceful degradation, and robust input validation using Zod schemas. A new structured logging system has been set up to capture performance metrics (processing time, cache hits/misses, suggestion counts), error tracking with detailed stack traces, user analytics via UID logging, and cache statistics. Additionally, performance enhancements such as hash-based smart caching that substantially reduces API calls, improved memory management with efficient TTL configurations, response streaming for real-time feedback, and token optimization have been implemented. Updated documentation now covers comprehensive API details, deployment instructions, manual testing via cURL, configuration guides for environment variables, and security best practices, ensuring the production-readiness of the grammar check endpoint.\n</info added on 2025-06-17T05:03:10.437Z>",
            "status": "done"
          }
        ]
      },
      {
        "id": 8,
        "title": "Integrate Real-time Grammar/Spell Suggestions in Editor",
        "description": "Integrate the real-time grammar and spelling suggestions from the backend endpoint into the DocumentEditor (DocumentEditor.tsx). This integration should provide a comprehensive grammar suggestions experience similar to the Grammarly interface, including a right sidebar for suggestions, visual highlighting in the editor, and interactive suggestion cards with controls.",
        "status": "pending",
        "dependencies": [
          6,
          7
        ],
        "priority": "high",
        "details": "In DocumentEditor.tsx, implement logic to send the editor content to the grammar/spell check endpoint (Task 7) as the user types (with debouncing). Parse and categorize the suggestions into Correctness, Clarity, Engagement, and Delivery. Implement a right sidebar UI to display the grouped grammar suggestions, similar to the Grammarly interface. In the main editor area, implement custom marks/decorations (using Lexical/Tiptap) to visually highlight the text ranges with suggestions. Implement interactive suggestion cards and controls, including hover cards that display explanations and action items (Accept, Dismiss, Explain) for each suggestion. Ensure full keyboard accessibility for navigating and accepting suggestions. Also, integrate the existing grammar checking service into the DocumentEditor instead of a standalone test page.",
        "testStrategy": "Verify that as the user types, content is correctly debounced and sent to the grammar/spell check endpoint. Confirm that suggestions are received, parsed, and correctly categorized into Correctness, Clarity, Engagement, and Delivery. Test the right sidebar UI to ensure suggestions are displayed in a structured and intuitive manner. Ensure that visual highlights in the editor correspond accurately to the suggested text ranges. Validate that interactive suggestion cards and controls (hover cards, Accept, Dismiss, Explain) function correctly via both mouse and keyboard. Perform integration tests to ensure the existing grammar checking service is properly integrated into the DocumentEditor.",
        "subtasks": [
          {
            "id": 1,
            "title": "Review Existing Services and Editor Structure",
            "description": "Analyze the current implementation of GrammarService and useGrammarCheck hook, and study DocumentEditor.tsx to identify integration points.",
            "dependencies": [],
            "details": "Examine GrammarTestPage usage and determine how the grammar functionalities can be migrated to DocumentEditor.tsx.\n<info added on 2025-06-17T17:12:33.335Z>\nAnalysis complete. The existing grammar services, hooks, and debouncing implementations have been thoroughly reviewed and confirmed to be production-ready. The plan for integrating useGrammarCheck into DocumentEditor includes importing the hook into DocumentEditor.tsx, connecting editor change events to the grammar service, and managing suggestion state in parallel with document state. Additionally, a dedicated grammar suggestion sidebar component will be created along with visual highlighting in the Lexical theme. Interactive controls such as hover cards for applying or dismissing suggestions are also planned. This integration strategy leverages the robust functionality proven in GrammarTestPage while aligning with DocumentEditor's current architecture and auto-save features.\n</info added on 2025-06-17T17:12:33.335Z>",
            "status": "done"
          },
          {
            "id": 2,
            "title": "Integrate useGrammarCheck into DocumentEditor",
            "description": "Embed the useGrammarCheck hook within DocumentEditor.tsx to enable grammar checking functionality.",
            "dependencies": [
              1
            ],
            "details": "Refactor DocumentEditor.tsx to call useGrammarCheck in appropriate lifecycle events, ensuring compatibility with existing editor features.\n<info added on 2025-06-17T17:14:49.332Z>\nIntegration complete. The DocumentEditor now imports useGrammarCheck and EditorSuggestion, integrating the hook with a 1000ms debounce delay, a 3-character minimum threshold, grammar and spelling enabled (with style disabled), and caching for performance. The handleEditorChange function has been updated to trigger grammar checks on content changes and to clear suggestions when the content is empty, all while preserving the existing auto-save functionality. Additionally, a real-time grammar status display has been added to the document stats header with color-coded statuses (blue: checking, amber: suggestions, green: ok), along with an error display component featuring retry functionality and robust error handling for authentication and API failures. Grammar suggestions are now managed alongside the document state with proper cleanup and error recovery measures. Ready for the next phase: Reviewing the debouncing implementation.\n</info added on 2025-06-17T17:14:49.332Z>",
            "status": "done"
          },
          {
            "id": 3,
            "title": "Implement Input Debouncing",
            "description": "Add a debounce mechanism for user input to avoid excessive calls to the grammar endpoint.",
            "dependencies": [
              2
            ],
            "details": "Use a debounce function to delay grammar checks until the user has paused typing, balancing performance and responsiveness.\n<info added on 2025-06-17T17:10:59.314Z>\nReview the existing debouncing hooks (useDebounce.ts and useGrammarDebounce) and integrate them into the DocumentEditor. The review should ensure these hooks are properly utilized, including their generic support with TypeScript, 1000ms delay in useGrammarDebounce, a minimum character threshold of 3, smart text change detection to prevent duplicate API calls, advanced controls for trigger, cancel, flush, and isActive, and automatic cleanup for memory management.\n</info added on 2025-06-17T17:10:59.314Z>\n<info added on 2025-06-17T17:16:27.845Z>\nDebouncing implementation review complete. The integration in DocumentEditor via useGrammarCheck and useGrammarDebounce has been verified with the following key points: a 1000ms delay and a minimum input length of 3 characters; smart duplicate detection that prevents redundant API calls; advanced control methods (trigger, cancel, flush, isActive) that ensure robust timeout management and memory cleanup; effective race condition mitigation using request ID tracking and AbortController; and performance optimizations including client-side caching with a 5-minute TTL. All aspects confirm that the debouncing flow is production-ready and optimally configured, allowing us to move forward to the GrammarService endpoint verification.\n</info added on 2025-06-17T17:16:27.845Z>",
            "status": "done"
          },
          {
            "id": 4,
            "title": "Setup GrammarService Endpoint Calls",
            "description": "Integrate calls to the GrammarService endpoint inside DocumentEditor.tsx after debouncing the input.",
            "dependencies": [
              3
            ],
            "details": "Ensure that the AI endpoint is triggered correctly, handling asynchronous requests and potential errors efficiently.\n<info added on 2025-06-17T17:24:23.495Z>\nGrammarService endpoint integration has been fully verified. The endpoint is correctly configured with the URL, POST method, and proper JSON payload including text, language, and flags, along with secure Firebase authentication and CORS settings for local development. Request handling is robust with validated payloads, length limits, client-side caching (5-minute TTL), and comprehensive error handling for various cases (401, 429, 5xx). The DocumentEditor’s integration via the useGrammarCheck hook demonstrates effective debouncing (1000ms delay), race condition prevention with unique request IDs and AbortController, and proper state management for loading, errors, and suggestions. Additionally, the retry mechanism and clear user feedback on errors confirm a production-ready integration.\n</info added on 2025-06-17T17:24:23.495Z>",
            "status": "done"
          },
          {
            "id": 5,
            "title": "Parse and Map Grammar Suggestions",
            "description": "Develop logic to parse the responses from GrammarService and map them to appropriate editor markings.",
            "dependencies": [
              4
            ],
            "details": "Extract suggestion data, categorize suggestions, and integrate the parsing mechanism to convert responses into custom visual marks in the Lexical editor.\n<info added on 2025-06-17T17:27:25.648Z>\nImplemented comprehensive enhancement of the suggestion parsing and mapping mechanism. Enhanced the type system by introducing GrammarCategory and CategorizedSuggestions types, supporting categories such as correctness, clarity, engagement, and delivery, and added optional severity levels (low, medium, high). Developed smart categorization logic that maps suggestions based on type, confidence scores, and context analysis—with rules assigning Grammar and Spelling to correctness, punctuation to either correctness or clarity, and style to delivery, engagement, or clarity, defaulting to clarity for unknown types. Upgraded the service layer with an intelligent _categorizeSuggestion() method and integrated these updates via createEditorSuggestions() and a new categorizeSuggestions() utility for UI grouping. Also integrated categorizedSuggestions into DocumentEditor for real-time state updates, enhancing the UI with category-specific counts, color-coded status bars, and visual badges for error or clarity. These improvements ensure efficient, memoized categorization, setting a robust foundation for the upcoming sidebar UI development.\n</info added on 2025-06-17T17:27:25.648Z>",
            "status": "done"
          },
          {
            "id": 6,
            "title": "Develop Right Sidebar UI for Suggestions",
            "description": "Design and implement a right sidebar to display categorized suggestions (Correctness, Clarity, Engagement, Delivery).",
            "dependencies": [
              5
            ],
            "details": "Create UI components that list suggestions, integrate state management to sync with the editor, and provide a clear categorization of grammar issues.\n<info added on 2025-06-17T17:32:54.757Z>\nAdded comprehensive RIGHT SIDEBAR implementation details: The GrammarSidebar component now features four collapsible, color-coded sections—Correctness, Clarity, Engagement, and Delivery—with dedicated icons and descriptions. Each suggestion is displayed with original and proposed text, detailed explanations, confidence scores, and color-coded type badges for grammar, spelling, punctuation, and style. The component also includes visually appealing empty states (\"Great writing!\") and spinner animations during grammar checks. Integration with the DocumentEditor has been enhanced using a flexbox layout with a fixed 320px sidebar, incorporating event handlers for applying, dismissing, and clearing suggestions, ensuring real-time state synchronization. Additional UI enhancements include category counts in the header, critical error badges, expandable categories, confidence indicators, positional text range details for suggestions, and accessible one-click actions with hover feedback.\n</info added on 2025-06-17T17:32:54.757Z>\n<info added on 2025-06-17T17:53:15.970Z>\nFixed the issue where accepted grammar suggestions only updated the sidebar state without modifying the actual Lexical editor content. The update ensures that handleApplySuggestion now calls editorRef.current.updateContent to trigger a re-render of the editor with the new text. This was accomplished by extending the LexicalEditor component with a LexicalEditorRef interface and implementing the UpdateContentPlugin using forwardRef and a timestamp-based trigger to force content refresh via Lexical’s $getRoot() API. These changes restore proper state synchronization between the React state and the Lexical editor’s internal state, ensuring that accepted changes (e.g., \"do es\" to \"do does\") are accurately reflected in the editor content.\n</info added on 2025-06-17T17:53:15.970Z>\n<info added on 2025-06-17T17:57:46.271Z>\nCritical Fix: Resolved infinite loop issue when accepting suggestions. Previously, handleApplySuggestion triggered updateContent, which in turn caused the editor's onChange event to run checkGrammar repeatedly, leading to an infinite loop. The solution now introduces an isApplyingSuggestion flag (using useRef) to bypass grammar checks during programmatic content updates. handleApplySuggestion sets this flag to true before updating the editor and resets it to false after a 500ms delay, while handleEditorChange now exits early if the flag is active. This update prevents the infinite loop, ensuring smooth suggestion application and consistent grammar rechecking without impacting performance.\n</info added on 2025-06-17T17:57:46.271Z>\n<info added on 2025-06-17T18:10:50.119Z>\nDEBUGGING: Added comprehensive logging to track execution in the suggestion application process. In handleApplySuggestion, logs now capture entry into the function, details of the received suggestion, results of applySuggestion, the progress of updating the editor content, state updates, flag management, and error handling with flag resets. The applySuggestion hook now logs input parameters, available suggestions, GrammarService method calls and outcomes, position corrections, and potential error conditions. Additionally, handleEditorChange includes logs for tracking content modifications, monitoring the isApplyingSuggestion flag status, and distinguishing between triggering or skipping grammar checks. These logs will help identify whether the freeze is due to an infinite loop between editor changes and grammar checks, issues in the GrammarService.applyTextSuggestion method, conflicts with Lexical's updateContent, or excessive React state updates.\n</info added on 2025-06-17T18:10:50.119Z>\n<info added on 2025-06-17T18:17:52.508Z>\nInfinite Loop fix applied: The UpdateContentPlugin now calls editor.update(callback, { discrete: true }), which prevents triggering the OnChangePlugin during programmatic updates. The grammar recheck timeout has been reduced from 1000ms to 100ms, and all debugging logs have been removed for production. This update ensures that the suggestion application mechanism updates the editor content immediately without causing repeated change events, maintaining correct grammar rechecking behavior.\n</info added on 2025-06-17T18:17:52.508Z>\n<info added on 2025-06-17T18:29:55.811Z>\nImplemented fix for text replacement and suggestion preservation issues. The applyTextSuggestion method now ignores the unreliable word boundary regex and directly uses the suggestion's position range to extract and replace the exact text span, ensuring that the full erroneous segment (e.g., \"do es\") is replaced with \"does.\" Additionally, the updateSuggestionsAfterChange function has been refined to remove suggestions only when there is more than 50% overlap with the applied change, with smart adjustments for partially overlapping suggestions. This approach preserves other suggestions that do not significantly conflict, such as punctuation errors. Next, testing will verify the correct behavior of both text replacement and suggestion preservation.\n</info added on 2025-06-17T18:29:55.811Z>\n<info added on 2025-06-17T18:46:17.285Z>\nCRITICAL FIX IMPLEMENTED: Text Replacement Issues Resolved\n\nRoot Cause Analysis:\n- Identified position drift where subsequent suggestions retained original positions after the first replacement.\n- Complex offset calculations were causing mismatches.\n- Noticed text mismatches, such as \"do does\" replacing an incorrect text segment.\n\nSolution Implemented:\nA complete rewrite of the applyTextSuggestion logic now utilizes a content-based search approach. The method initially attempts to use the original positions; if a text mismatch is detected, it falls back to using indexOf() to locate the exact text. If still unsuccessful, a fuzzy search within a ±20 character range is employed. This change eliminates position drift issues, simplifies the hook logic by removing unnecessary applied suggestions tracking and offset updates, and ensures that once a suggestion is applied, it is simply removed from the list.\n\nEnhanced Debugging:\nComprehensive logging has been added to capture details about position detection, fallback search usage, and before/after text comparisons to further monitor and verify the correct behavior during suggestion application.\n\nExpected Results:\n- Correctly replacing \"do es\" with \"does\" by accurately finding and replacing the text segment.\n- Proper replacement for punctuation cases, such as \". .\" to \".\".\n- Sidebar retains only non-conflicting suggestions.\n- No longer encountering issues like \"doeses\" or mismatched character placements.\n\nTechnical Implementation:\nGrammarService.applyTextSuggestion now leverages a content-based search strategy, and useGrammarCheck.applySuggestion has been simplified to remove complex position tracking while ensuring that applied suggestions are directly removed from the list.\n</info added on 2025-06-17T18:46:17.285Z>\n<info added on 2025-06-17T19:14:15.961Z>\nCOMPREHENSIVE FIXES IMPLEMENTED: Resolved Lost Suggestions, Conflicting Loops, and Description Mismatches.\n\nIssues Addressed:\n1. Lost Suggestions Problem – Removed the automatic call to checkGrammar in handleApplySuggestion to ensure that remaining valid suggestions persist until the user types naturally.\n2. Conflicting Suggestions Loop – Enhanced the OpenAI prompt with explicit consistency rules and context-aware punctuation guidelines (e.g., handling interrogative words) to prevent contradictory suggestions.\n3. Description/Suggestion Mismatch – Implemented validation functions (_validateExplanation and _generateCorrectExplanation) to auto-correct mismatches between the suggested changes and their explanations, ensuring accurate descriptions for changes such as capitalization and punctuation.\n\nTechnical Improvements:\n• DocumentEditor now delays grammar rechecks until user typing resumes, preventing immediate clearing of suggestions.\n• OpenAI prompt enhancements enforce clear, consistent punctuation and descriptive guidelines.\n• GrammarService validation now automatically corrects explanation discrepancies during suggestion parsing.\n• All debug console logs have been removed for cleaner, production-level code.\n\nExpected results:\n• Persistent suggestions after application.\n• Consistent, non-contradictory grammar suggestions.\n• Accurate, reliable description of changes, mirroring the functionality of professional tools.\n</info added on 2025-06-17T19:14:15.961Z>",
            "status": "done"
          },
          {
            "id": 7,
            "title": "Implement Custom Marks and Interactive Hover Cards",
            "description": "Enable visual highlighting in the Lexical editor and build interactive hover cards for displaying detailed suggestion information.",
            "dependencies": [
              5
            ],
            "details": "Add custom mark functionality in the editor; design hover cards with suggestion controls that appear on hover over marked text, ensuring they interact seamlessly with the editor.",
            "status": "pending"
          },
          {
            "id": 8,
            "title": "Ensure Keyboard Accessibility and Final Integration",
            "description": "Test and implement keyboard navigation and accessibility for the sidebar, hover cards, and suggestion controls.",
            "dependencies": [
              6,
              7
            ],
            "details": "Conduct accessibility audits to confirm full keyboard support, proper ARIA attributes, and effective state synchronization between the editor and UI components.",
            "status": "pending"
          }
        ]
      },
      {
        "id": 9,
        "title": "Implement Live Metrics Panel",
        "description": "Implement the Live Metrics Panel UI in the right sidebar and integrate real-time calculation and display of word count, estimated reading time, and Flesch-Kincaid grade.",
        "details": "Create the UI component for the right sidebar metrics panel using React and Tailwind. Implement logic to calculate word count, estimated reading time (e.g., 200 words/minute), and Flesch-Kincaid grade based on the editor content. Update these metrics in real-time as the user types. Display the metrics in the panel. Ensure the footer word count sticks bottom-center.",
        "testStrategy": "Verify metrics update accurately and in real-time as text is added/removed. Test calculations for word count, reading time, and Flesch-Kincaid score with sample texts.",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design Live Metrics UI",
            "description": "Design the UI elements for the Live Metrics Panel, focusing on the right sidebar layout and footer positioning.",
            "dependencies": [],
            "details": "Create mockups and design prototypes for the panel, ensuring responsive design and proper alignment of sidebar components and footer placement.",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "Develop Real-Time Metrics Calculation",
            "description": "Implement the logic to calculate word count, estimated reading time, and Flesch-Kincaid grade in real time.",
            "dependencies": [],
            "details": "Set up algorithms for text analysis with live updating capabilities, ensuring accurate and efficient computation of metrics.",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Integrate UI with Real-Time Logic",
            "description": "Combine the designed UI with the real-time calculation logic and adjust layout for consistency.",
            "dependencies": [
              1,
              2
            ],
            "details": "Integrate the UI components with the backend logic, test for responsiveness and proper layout updating, and ensure that the footer and sidebar remain correctly positioned during live updates.",
            "status": "pending"
          }
        ]
      },
      {
        "id": 10,
        "title": "Develop Passive Voice Detection AI Endpoint",
        "description": "Develop a Cloud Function endpoint to detect passive voice constructions in text and propose active-voice rewrites using GPT-4o.",
        "details": "Create a Firebase Cloud Function similar to the grammar check endpoint. Use GPT-4o with a prompt specifically designed to identify passive voice and suggest active voice alternatives. Return suggestions in the same structured format (range, type='passive', original, proposed, explanation). Leverage the caching mechanism established in Task 7.",
        "testStrategy": "Test the endpoint with sentences containing passive voice. Verify accurate detection and relevant active voice suggestions are returned in the correct format.",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Architecture and Requirements",
            "description": "Outline the overall design for the Cloud Function, including integration with GPT-4o, the passive voice detection logic, and caching mechanism similar to the grammar check endpoint.",
            "dependencies": [],
            "details": "Establish technical requirements, data flow diagrams, and interface contracts for each component of the system.",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "Craft Specific Passive Voice Detection Prompt",
            "description": "Develop a detailed prompt tailored for detecting passive voice using GPT-4o, ensuring robust detection and appropriate response formatting.",
            "dependencies": [
              1
            ],
            "details": "Create prompt options, test with sample texts, and refine the language instructions to accurately capture passive constructs.",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Implement Cloud Function & Structured Response Formatting",
            "description": "Develop the Cloud Function that calls GPT-4o with the crafted passive voice detection prompt and implements structured response formatting.",
            "dependencies": [
              2
            ],
            "details": "Write the function code, set up API calls, process GPT-4o responses, and ensure output adheres to the defined formatting structure.",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "Integrate Caching Mechanism",
            "description": "Incorporate caching mechanisms similar to the grammar check endpoint to optimize performance and reduce redundant API calls.",
            "dependencies": [
              3
            ],
            "details": "Design and implement caching strategies, using suitable cache storage, and test for efficiency and correctness under various loads.",
            "status": "pending"
          }
        ]
      },
      {
        "id": 11,
        "title": "Integrate Passive Voice Suggestions in Editor",
        "description": "Integrate the passive voice suggestions from the backend endpoint into the rich-text editor UI, similar to grammar/spell check.",
        "details": "Extend the editor integration logic (Task 8) to also send content to the passive voice endpoint (Task 10). Implement distinct highlighting/underlining for passive voice suggestions. Reuse or adapt the hover card and action bar components for passive voice suggestions (Accept, Dismiss, Explain). Ensure keyboard navigation includes passive voice suggestions.",
        "testStrategy": "Verify passive voice constructions are highlighted in the editor. Test hover cards and actions for passive voice suggestions. Ensure grammar/spell and passive voice suggestions coexist correctly.",
        "priority": "medium",
        "dependencies": [
          6,
          10
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Analyze and Document Existing Editor Logic",
            "description": "Review and document the current rich-text editor architecture and integration points, focusing on grammar and spell-check functionalities to identify potential integration areas for passive voice suggestions.",
            "dependencies": [],
            "details": "Examine how the editor processes suggestions, and note any existing data structures or event handling that will be extended to support passive voice detection. Create a documentation file listing key modules and components.",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "Extend Logic for Passive Voice Detection",
            "description": "Modify and extend the existing suggestion logic to detect and handle passive voice usage, ensuring seamless operation alongside grammar and spell-check suggestions.",
            "dependencies": [
              1
            ],
            "details": "Implement new functions or modify existing ones to analyze sentence structure for passive voice patterns. Ensure that the passive voice detection can correctly trigger suggestions without interfering with other editor functionalities.",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Implement Distinct Highlighting for Passive Voice Suggestions",
            "description": "Develop and integrate a distinct visual highlighting mechanism for passive voice suggestions within the rich-text editor, differentiating them from other types of suggestions.",
            "dependencies": [
              2
            ],
            "details": "Define new CSS classes or styles for passive voice suggestions and integrate these into the editor's rendering logic. Test to ensure that the highlighting stands out and does not conflict with existing styles.",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "Develop Hover Cards and Keyboard Navigation for Passive Voice Suggestions",
            "description": "Create interactive hover cards and keyboard navigation features to enhance user interaction with passive voice suggestions, ensuring an intuitive and accessible user experience.",
            "dependencies": [
              2,
              3
            ],
            "details": "Design the UI component for hover cards that provide detailed info on passive voice usage. Implement keyboard event handlers to allow users to navigate through suggestions using keys, ensuring compliance with accessibility standards.",
            "status": "pending"
          }
        ]
      },
      {
        "id": 12,
        "title": "Implement Personal Dictionary",
        "description": "Implement backend (Firestore, Cloud Function) and frontend (UI) for managing the user's personal dictionary and integrate it into the suggestion logic to prevent false positives.",
        "details": "Add a 'dictionary' array field to the User document in Firestore. Create Cloud Functions for adding, removing, and listing dictionary terms. Build a UI component (e.g., in Account settings or a modal) for users to manage their dictionary. Modify the grammar/spell check and passive voice Cloud Functions (Tasks 7, 10) to fetch the user's dictionary and filter out suggestions that match dictionary terms before returning them.",
        "testStrategy": "Test adding, removing, and listing dictionary terms via the UI and backend. Verify that terms added to the dictionary are no longer flagged as errors or passive voice in the editor.",
        "priority": "medium",
        "dependencies": [
          4,
          11
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Update Firestore User Documents",
            "description": "Modify the Firestore schema to include personal dictionary fields in user documents.",
            "dependencies": [],
            "details": "Review the current Firestore structure, design the dictionary field schema, update user documents to include word lists, and ensure proper indexing and security rules are applied.",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "Create Cloud Functions for CRUD Operations",
            "description": "Develop Cloud Functions to handle Creating, Reading, Updating, and Deleting dictionary terms.",
            "dependencies": [
              1
            ],
            "details": "Implement endpoints for dictionary term management, integrate authentication checks, and ensure these functions interact properly with the updated Firestore schema.",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Build the Dictionary Management UI",
            "description": "Design and implement a user interface that allows users to manage their personal dictionary.",
            "dependencies": [
              1,
              2
            ],
            "details": "Develop the frontend components for viewing, adding, editing, and deleting dictionary words. Ensure that the UI communicates with the Cloud Functions and handles validation and error states.",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "Integrate Dictionary Check Logic into Endpoints",
            "description": "Enhance the grammar and passive voice endpoints to incorporate personal dictionary checks.",
            "dependencies": [
              1,
              2
            ],
            "details": "Modify the existing endpoints to include logic that checks against the user's personal dictionary when processing suggestions. Test the integration thoroughly to maintain endpoint performance and accuracy.",
            "status": "pending"
          }
        ]
      },
      {
        "id": 13,
        "title": "Setup GitHub Actions CI/CD",
        "description": "Set up GitHub Actions CI/CD workflow for linting, building, and testing on push and pull requests.",
        "details": "Create a new workflow file (e.g., `ci.yml`) in the `.github/workflows` directory. Configure the workflow to trigger on `push` and `pull_request` events targeting the main branch. Define jobs for:\n1.  **Linting**: Run linters (ESLint, Prettier) to ensure code style and quality.\n2.  **Building**: Build the frontend application and potentially the backend Cloud Functions.\n3.  **Testing**: Run unit and integration tests for both frontend and backend code.\n\nUse `actions/checkout` to get the code and `actions/setup-node` to set up the Node.js environment (specify version 20). Use `npm ci` for installing dependencies to ensure deterministic builds. Configure caching for node modules to speed up subsequent runs. Ensure the necessary scripts (`lint`, `build`, `test`) are defined in `package.json` and are executed correctly in the workflow.",
        "testStrategy": "Create a pull request with some code changes to trigger the workflow. Push changes directly to a feature branch and then to the main branch (if allowed) to test push triggers. Verify that the workflow runs automatically for both events. Check the GitHub Actions UI to ensure all steps (lint, build, test) pass successfully. Introduce intentional errors (e.g., linting error, failing test) in a test branch to confirm the workflow fails as expected.",
        "status": "pending",
        "dependencies": [
          1,
          3,
          4
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize GitHub Actions Workflow",
            "description": "Create the basic GitHub Actions YAML file to define the workflow structure.",
            "dependencies": [],
            "details": "Set up a .github/workflows directory, and create an initial YAML file. Define a basic job to ensure the workflow file is recognized by GitHub.",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "Configure Linting, Build, and Test Jobs",
            "description": "Define and set up separate jobs in the workflow for linting, building, and testing the project.",
            "dependencies": [
              1
            ],
            "details": "Add individual jobs for linting (e.g., ESLint), building the codebase (e.g., npm run build), and running tests (e.g., npm test). Ensure that each job utilizes the appropriate actions and scripts.",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Set Trigger Events and Caching",
            "description": "Configure workflow triggers and optimize performance by setting up caching for node modules.",
            "dependencies": [
              2
            ],
            "details": "Configure the workflow to run on push and pull request events. Implement caching strategies for dependency management (e.g., caching node_modules) to improve job run times.",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "Verify Workflow Functionality",
            "description": "Ensure that the GitHub Actions workflow runs successfully through test cases and debugging.",
            "dependencies": [
              3
            ],
            "details": "Run tests to verify each job's functionality in the CI/CD pipeline. Analyze logs and debug issues to validate that linting, building, and testing jobs complete successfully.",
            "status": "pending"
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-06-16T19:55:35.907Z",
      "updated": "2025-06-17T17:33:25.586Z",
      "description": "Tasks for master context"
    }
  }
}